CREATE TABLE Artists (
    Artist_ID    INTEGER PRIMARY KEY,
    Artist_Name  TEXT Not Null,
    Genre        TEXT,
    Country      TEXT,
    Active_Since DATE
);

CREATE TABLE Songs (
    Song_ID INTEGER Primary Key,
    Title TEXT Not Null,
    Artist_ID INTEGER,
    Album TEXT,
    Release_Date DATE,
    Duration_Seconds INTEGER,
    Popularity_Score INTEGER
);

CREATE TABLE Customers (
    Customer_ID INTEGER Primary Key,
    First_Name TEXT Not Null,
    Last_Name TEXT Not Null,
    Email TEXT Not Null,
    Join_Date  DATE,
    Premium_Member BOOLEAN
);

CREATE TABLE Purchases (
    Purchase_ID INTEGER Primary Key,
    customer_ID INTEGER Customers,
    Song_ID INTEGER,
    Purchase_date DATE,
    Price DECIMAL
);

CREATE TABLE Streams (
    Stream_ID INTEGER Primary Key,
    Customer_ID INTEGER,
    Song_ID INTEGER,
    Stream_Date DATE,
    Stream_Time TIME
    );
    

--Retrieve the titles and release dates of all songs released in 2022, ordered by release date (newest first).
SELECT Title, Release_Date from Songs WHERE Release_Date BETWEEN '2022-01-01' AND '2022-12-31' ORDER BY Release_Date ASC;


--Filtering: Find all songs with a popularity score greater than 80 and a duration less than 4 minutes (240 seconds).
SELECT Song_ID from Songs where Popularity_Score >80 AND Duration_Seconds < 240;


--Pattern Matching: List all artists whose names start with "The".
SELECT Artist_Name from Artists WHERE Artist_Name Like 'The%';


--Multiple Conditions: Find all premium customers who joined in 2022.
SELECT * from Customers WHERE Join_Date LIKE '2022%' AND Premium_Member LIKE 't%';

--Calculate the total duration (in minutes) of all songs in the database and display the result with an appropriate column name.
SELECT SUM(Duration_Seconds)/60 AS Total_Duration_Minutes from Songs; 

--Advanced Filtering: Find the top 5 most expensive song purchases in the database.
SELECT Song_ID from Purchases ORDER BY Price DESC
LIMIT 5;

--First, find all song_ids from songs with a popularity score above 90. Then, use those song_ids to find purchases of those songs.
SELECT * from Purchases WHERE Song_ID IN (
SELECT Song_ID from Songs WHERE Popularity_Score >90
);

--Find all purchases made between January 1, 2023 and March 31, 2023.
SELECT * from Purchases WHERE Purchase_date BETWEEN '2023-01-01' AND '2023-03-31';

--: Identify the songs with the highest popularity scores (above 90).
SELECT * from Songs WHERE Popularity_Score >90 ORDER BY Popularity_Score DESC;

--Discussion Questions
/* 1. Enforces data integrity using appropriate constraints and data types 
Avoids many NULL values that would exist in a single user interactions table
nables clearer schemas with columns specific to each interaction type
Improves query performance for example simpler SELECT function, fewer filters)/*

/* 2. What genres perform best by country or region
What are the seasonal trends in streaming vs purchasing
Do premium members purchase more songs or stream more frequently than non-premium users?
Are new releases driving more streams or purchases compared to older songs?
How many artists are based in the United States compared to Canada?
Which customers are highly engaged but not purchasing
How does song popularity score relate to actual streams and purchases?/*

/* 3. To track more detailed user behavior, you could extend the schema in a clean, scalable way by enhancing the Streams data rather than overloading existing tables.
We can create a separate Stream_Events table to log actions like play, pause, and skip with timestamps.
Add listening-behavior fields to Streams (e.g., listened_seconds, completion_percentage, skipped).
Link events to Customers and Songs using foreign keys.*/

/* 4. hree tasks using JOINs, WHERE conditions, and pattern matching in one query



